# Future Roadmap: Real Hardware Biometric Integration (WebAuthn/FIDO2)

Currently, the application uses a **Smart Simulation** for biometric authentication. This works by generating a unique token on the client side and trusting the client to store it securely.

For a production environment dealing with sensitive data, you should transition to **WebAuthn (FIDO2)**. This standard allows the browser to communicate directly with the device's secure hardware (Face ID, Touch ID, Windows Hello).

---

## 1. Concept Overview

| Feature | Current (Simulation) | Future (WebAuthn) |
| :--- | :--- | :--- |
| **Credential** | Random string (UUID) stored in `localStorage`. | Public-Private Key Pair generated by hardware chip. |
| **Security** | Low (Token can be copied if device is compromised). | High (Private key never leaves the hardware). |
| **Login Logic** | Frontend sends token -> Backend looks it up. | Backend sends Challenge -> Hardware signs it -> Backend verifies signature. |

---

## 2. Frontend Implementation (`LoginPage.tsx`, `RegisterPage.tsx`)

You will need to use the browser's `navigator.credentials` API.

### Registration (Enrollment)
Instead of generating a random string, you ask the browser to create a credential.

```typescript
// Register new credential
const publicKey = {
    challenge: Uint8Array.from(serverChallenge, c => c.charCodeAt(0)),
    rp: { name: "ACCESS.AI" },
    user: {
        id: Uint8Array.from(userId, c => c.charCodeAt(0)),
        name: userEmail,
        displayName: userFullName
    },
    pubKeyCredParams: [{ alg: -7, type: "public-key" }],
    authenticatorSelection: { authenticatorAttachment: "platform" }, // Use built-in (FaceID/TouchID)
    timeout: 60000,
    attestation: "direct"
};

const credential = await navigator.credentials.create({ publicKey });
// Send 'credential' to backend to store the Public Key
```

### Authentication (Login)
Instead of reading from `localStorage`, you ask the browser to sign a challenge.

```typescript
// Login with credential
const publicKey = {
    challenge: Uint8Array.from(serverChallenge, c => c.charCodeAt(0)),
    timeout: 60000,
    allowCredentials: [{
        id: storedCredentialId, // Optional: if you know who is trying to login
        type: "public-key"
    }]
    // If identifying user (1:N), leave allowCredentials empty or minimal
};

const assertion = await navigator.credentials.get({ publicKey });
// Send 'assertion' to backend to verify signature
```

---

## 3. Backend Implementation (`auth.py`)

You will need a library to handle the complex cryptography.
**Recommended Library:** `webauthn` or `fido2` (Python).

### New Dependencies
Add to `requirements.txt`:
```text
webauthn==2.0.0
```

### New Workflows

1.  **GET /auth/webauthn/challenge**:
    *   Backend generates a random "Challenge" string.
    *   Saves it temporarily (in Redis or Session).
    *   Returns it to Frontend.

2.  **POST /auth/register/biometric (Verify Attestation)**:
    *   Receives the `credential` from Frontend.
    *   Verifies that the challenge matches.
    *   Extracts and saves the **Public Key** and **Credential ID** to the `User` table.

3.  **POST /auth/login/biometric (Verify Assertion)**:
    *   Receives the `assertion` from Frontend.
    *   Finds the user associated with the Credential ID.
    *   Verifies the signature using the stored Public Key.
    *   If valid, issues a JWT.

---

## 4. Infrastructure Requirements

*   **HTTPS is Mandatory**: WebAuthn **will not work** on `http://` (except `localhost`). You must deploy with SSL/TLS.
*   **Domain Binding**: Credentials are bound to the domain (e.g., `access.ai`). You cannot register on `localhost` and login on `production.com`.

---

## 5. Migration Strategy

1.  **Keep Existing System**: existing `face_id_data` works as a fallback.
2.  **Add toggle in User Settings**: "Upgrade to Secure Hardware Login".
3.  **Trigger Enrollment**: User clicks "Upgrade", browser prompts for FaceID/TouchID.
4.  **Save Public Key**: Backend stores the new key.
5.  **Switch Logic**: If user has Public Key, enforce WebAuthn challenge/response flow.
